{
    "CP Minimal Template": {
        "prefix": "cp",
        "body": [
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "#define int long long",
            "const int MOD = 1e9+7;",
            "",
            "",
            "// Observations",
            "/*",
            "",
            "",
            "",
            "",
            "*/",
            "",
            "",
            "void solve(){",
            "",
            "}",
            "",
            "int32_t main(){",
            "    ios_base::sync_with_stdio(false);",
            "    cin.tie(0);",
            "    cout.tie(0);",
            "",
            "    int t; cin >> t;",
            "    while(t--) solve();",
            "",
            "}"
        ],
        "description": "Minimal Competitive Programming Template"
    },

        "CSES Minimal Template": {
        "prefix": "cses",
        "body": [
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "#define int long long",
            "const int MOD = 1e9+7;",
            "",
            "",
            "// Observations",
            "/*",
            "",
            "",
            "",
            "",
            "*/",
            "",
            "",
            "",
            "int32_t main(){",
            "    ios_base::sync_with_stdio(false);",
            "    cin.tie(0);",
            "    cout.tie(0);",
            "",
           
            "}"
        ],
        "description": "CSES Template"
    },

        "Trie Template": {
        "prefix": "trieclass",
        "body": [
            "class Trie {",
            "public:",
            "",
            "    Trie* arr[26];",
            "    bool flag;",
            "",
            "    Trie() {",
            "        for (int i = 0; i < 26; i++)",
            "            arr[i] = nullptr;",
            "        flag = false;",
            "    }",
            "",
            "    void insert(const string &word) {",
            "        Trie* node = this;",
            "        for (char ch : word) {",
            "            int ind = ch - 'a';",
            "            if (node->arr[ind] == nullptr) {",
            "                node->arr[ind] = new Trie();",
            "            }",
            "            node = node->arr[ind];",
            "        }",
            "        node->flag = true;",
            "    }",
            "",
            "    bool search(const string &word) {",
            "        Trie* node = this;",
            "        for (char ch : word) {",
            "            int ind = ch - 'a';",
            "            if (node->arr[ind] == nullptr) {",
            "                return false;",
            "            }",
            "            node = node->arr[ind];",
            "        }",
            "        return node->flag;",
            "    }",
            "",
            "    bool startsWith(const string &prefix) {",
            "        Trie* node = this;",
            "        for (char ch : prefix) {",
            "            int ind = ch - 'a';",
            "            if (node->arr[ind] == nullptr) {",
            "                return false;",
            "            }",
            "            node = node->arr[ind];",
            "        }",
            "        return true;",
            "    }",
            "};"
        ],
        "description": "Trie Template"
    },
    "DSU class": {
    "prefix": "dsuclass",
    "body": [
      "class DSU {",
      "public:",
      "    vector<int> parent, rank;",
      "",
      "    DSU(int n) {",
      "        parent.resize(n);",
      "        rank.resize(n, 0);",
      "        for (int i = 0; i < n; i++)",
      "            parent[i] = i;",
      "    }",
      "",
      "    int find(int x) {",
      "        if (parent[x] != x)",
      "            parent[x] = find(parent[x]);",
      "        return parent[x];",
      "    }",
      "",
      "    void unite(int x, int y) {",
      "        int rx = find(x);",
      "        int ry = find(y);",
      "        if (rx == ry) return;",
      "        if (rank[rx] < rank[ry]) {",
      "            parent[rx] = ry;",
      "        } else if (rank[rx] > rank[ry]) {",
      "            parent[ry] = rx;",
      "        } else {",
      "            parent[ry] = rx;",
      "            rank[rx]++;",
      "        }",
      "    }",
      "};"
    ],
    "description": "C++ DSU / Union-Find class with path compression and union by rank"
    },

}

